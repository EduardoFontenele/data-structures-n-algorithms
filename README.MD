# GCC Compilation Guide

## ğŸ“‹ VisÃ£o Geral

Este guia explica como compilar projetos C com mÃºltiplas dependÃªncias usando GCC, desde compilaÃ§Ã£o simples atÃ© projetos complexos com bibliotecas externas.

## ğŸ”§ Flags Essenciais do GCC

| Flag | PropÃ³sito | Exemplo |
|------|-----------|---------|
| `-c` | Compila sem linkar (gera .o) | `gcc -c file.c -o file.o` |
| `-o` | Especifica nome do executÃ¡vel | `gcc file.c -o programa` |
| `-I` | Adiciona diretÃ³rio de headers | `gcc -Iheaders file.c` |
| `-L` | Adiciona diretÃ³rio de bibliotecas | `gcc -Llib file.c` |
| `-l` | Linka biblioteca especÃ­fica | `gcc file.c -lmath` |
| `-Wall` | Habilita warnings bÃ¡sicos | `gcc -Wall file.c` |
| `-Wextra` | Warnings extras | `gcc -Wall -Wextra file.c` |
| `-std=c99` | Especifica padrÃ£o C | `gcc -std=c99 file.c` |
| `-g` | InformaÃ§Ãµes de debug | `gcc -g file.c` |

## ğŸ¯ Processo de CompilaÃ§Ã£o

### 1. Arquivo Ãšnico
```bash
# CompilaÃ§Ã£o direta
gcc programa.c -o programa

# Com flags de qualidade
gcc -Wall -Wextra -std=c99 -g programa.c -o programa
```

### 2. MÃºltiplos Arquivos na Mesma Pasta
```bash
# Compila tudo junto
gcc main.c utils.c math.c -o programa

# Com headers em subpasta
gcc main.c utils.c math.c -Iheaders -o programa
```

### 3. CompilaÃ§Ã£o Separada (Recomendado)

#### Passo 1: Compilar para objetos (.o)
```bash
# Compila cada .c para .o
gcc -c main.c -Iheaders -o main.o
gcc -c utils.c -Iheaders -o utils.o
gcc -c math.c -Iheaders -o math.o
```

#### Passo 2: Linkar objetos
```bash
# Junta todos os .o em executÃ¡vel
gcc main.o utils.o math.o -o programa
```

## ğŸ—ï¸ Projetos com Estrutura de Pastas

### Estrutura TÃ­pica
```
projeto/
â”œâ”€â”€ src/           # Arquivos .c
â”œâ”€â”€ headers/       # Arquivos .h
â”œâ”€â”€ obj/           # Arquivos .o (gerados)
â”œâ”€â”€ lib/           # Bibliotecas externas
â””â”€â”€ bin/           # ExecutÃ¡veis finais
```

### Comandos por Pasta
```bash
# Compilar sources para objetos
gcc -c src/main.c -Iheaders -o obj/main.o
gcc -c src/utils.c -Iheaders -o obj/utils.o

# Linkar objetos
gcc obj/main.o obj/utils.o -o bin/programa
```

## ğŸ”— DependÃªncias Externas

### CenÃ¡rio: Projeto usa biblioteca externa

**Estrutura:**
```
workspace/
â”œâ”€â”€ meu_projeto/
â”‚   â”œâ”€â”€ src/main.c
â”‚   â””â”€â”€ headers/
â””â”€â”€ biblioteca_externa/
    â”œâ”€â”€ src/lib.c
    â”œâ”€â”€ headers/lib.h
    â””â”€â”€ obj/lib.o
```

### Ordem de CompilaÃ§Ã£o

#### 1. Compilar dependÃªncia externa
```bash
# Dentro de biblioteca_externa/
gcc -c src/lib.c -Iheaders -o obj/lib.o
```

#### 2. Compilar projeto principal
```bash
# Dentro de meu_projeto/
gcc -c src/main.c -Iheaders -I../biblioteca_externa/headers -o obj/main.o
```

#### 3. Linkar tudo
```bash
# Dentro de meu_projeto/
gcc obj/main.o ../biblioteca_externa/obj/lib.o -o bin/programa
```

## âš¡ Comandos Completos Reais

### Exemplo 1: Projeto simples
```bash
# Uma linha sÃ³
gcc src/main.c src/utils.c -Iheaders -Wall -Wextra -std=c99 -g -o programa
```

### Exemplo 2: Com dependÃªncia externa
```bash
# CompilaÃ§Ã£o completa de projeto complexo
gcc src/main.c \
    obj/local_lib.o \
    ../external_lib/obj/external.o \
    -Iheaders \
    -I../external_lib/headers \
    -Wall -Wextra -std=c99 -g \
    -o bin/programa
```

### Exemplo 3: Com bibliotecas do sistema
```bash
# Usando matemÃ¡tica e threading
gcc src/main.c obj/utils.o -Iheaders -lmath -lpthread -o programa
```

## ğŸ”„ Workflow Recomendado

### Para Desenvolvimento
1. **Organizar estrutura** de pastas
2. **Compilar dependÃªncias** primeiro (bottom-up)
3. **Compilar projeto** principal
4. **Linkar** tudo junto

### Comandos em SequÃªncia
```bash
# 1. Criar diretÃ³rios
mkdir -p obj bin

# 2. Compilar dependÃªncias
gcc -c ../dependency/src/dep.c -I../dependency/headers -o ../dependency/obj/dep.o

# 3. Compilar projeto
gcc -c src/main.c -Iheaders -I../dependency/headers -o obj/main.o

# 4. Linkar final
gcc obj/main.o ../dependency/obj/dep.o -o bin/programa
```

## ğŸ“ Makefile AutomÃ¡tico

Para projetos complexos, use Makefile:

```makefile
# VariÃ¡veis
CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -g
SRCDIR = src
HEADERDIR = headers
OBJDIR = obj
BINDIR = bin

# DependÃªncias externas
EXT_OBJDIR = ../external_lib/obj
EXT_HEADERDIR = ../external_lib/headers

# Target principal
programa: $(OBJDIR)/main.o $(EXT_OBJDIR)/external.o | $(BINDIR)
	$(CC) $(CFLAGS) $^ -o $(BINDIR)/$@

# Compilar objetos locais
$(OBJDIR)/%.o: $(SRCDIR)/%.c | $(OBJDIR)
	$(CC) $(CFLAGS) -I$(HEADERDIR) -I$(EXT_HEADERDIR) -c $< -o $@

# Criar diretÃ³rios
$(OBJDIR):
	mkdir -p $(OBJDIR)

$(BINDIR):
	mkdir -p $(BINDIR)

clean:
	rm -rf $(OBJDIR) $(BINDIR)

.PHONY: clean
```

## ğŸš¨ Problemas Comuns

### "No such file or directory"
**Causa:** Caminho errado para headers ou sources
```bash
# âŒ Errado
gcc -Iheader src/main.c  # pasta chama "headers"

# âœ… Correto  
gcc -Iheaders src/main.c
```

### "Undefined reference to function"
**Causa:** Esqueceu de linkar objeto/biblioteca
```bash
# âŒ SÃ³ compilou main.c, mas usa funÃ§Ãµes de utils.c
gcc main.c -o programa

# âœ… Inclui utils.c ou utils.o
gcc main.c utils.c -o programa
```

### "Multiple definition"
**Causa:** Incluiu .c em vez de .h, ou linkOU o mesmo objeto duas vezes
```bash
# âŒ Errado - inclui implementaÃ§Ã£o
#include "utils.c"

# âœ… Correto - inclui sÃ³ declaraÃ§Ãµes
#include "utils.h"
```

## ğŸ’¡ Dicas AvanÃ§adas

### Debug de Linking
```bash
# Ver sÃ­mbolos em objeto
nm arquivo.o

# Ver dependÃªncias dinÃ¢micas
ldd programa

# Verbose linking
gcc -v arquivos... -o programa
```

### OtimizaÃ§Ã£o
```bash
# Debug
gcc -g -O0 arquivos... -o programa_debug

# Release
gcc -O2 -DNDEBUG arquivos... -o programa_release
```

### Cross-compilation
```bash
# Compile para 32-bit em sistema 64-bit
gcc -m32 arquivos... -o programa32
```

## ğŸ¯ Checklist RÃ¡pido

- [ ] Estrutura de pastas organizada
- [ ] Headers (.h) separados de implementaÃ§Ã£o (.c)
- [ ] Compilar dependÃªncias primeiro
- [ ] Usar `-I` para todos os diretÃ³rios de headers necessÃ¡rios
- [ ] Linkar todos os objetos (.o) necessÃ¡rios
- [ ] Testar com flags de warning (`-Wall -Wextra`)
- [ ] Makefile para projetos grandes

---

**Lembre-se:** GCC Ã© poderoso mas verboso. Use Makefiles para automatizar comandos longos!